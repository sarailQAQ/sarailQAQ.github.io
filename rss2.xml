<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sarail wanna sleep all day</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Fast Fishing Transform</description>
    <pubDate>Fri, 23 Apr 2021 01:02:37 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2020ECFinal(Middle?)游记</title>
      <link>http://example.com/2021/04/23/2020ECFinal-Middle-%E6%B8%B8%E8%AE%B0/</link>
      <guid>http://example.com/2021/04/23/2020ECFinal-Middle-%E6%B8%B8%E8%AE%B0/</guid>
      <pubDate>Fri, 23 Apr 2021 01:01:31 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;由于之前南京站的那块银牌，捡了个ec final的出线名额。打icpc至今还没有打过线下赛，非常兴奋。不过疫情期间，手续也相对麻烦，好在学校这边不需要提交什么特别的申请，辅导员也对我出去比赛非常支持，很快就搞定了。&lt;/p&gt;
&lt;h2 id=&quot;4-16&quot;&gt;&lt;a href=&quot;#4</description>
        
      
      
      
      <content:encoded><![CDATA[<p>由于之前南京站的那块银牌，捡了个ec final的出线名额。打icpc至今还没有打过线下赛，非常兴奋。不过疫情期间，手续也相对麻烦，好在学校这边不需要提交什么特别的申请，辅导员也对我出去比赛非常支持，很快就搞定了。</p><h2 id="4-16"><a href="#4-16" class="headerlink" title="4.16"></a>4.16</h2><p>出发去西安！</p><p>由于飞机票都比较坑（需要经停），所以我们选择了坐火车去。早上9点出发，结果刚好撞到早高峰，一度以为要误车了。不过还是提前20多分钟到重庆西站，而且西站人不算很多，很快就进去了。</p><p>火车上没网比较无聊，还好我提前下载了一季赛马娘。特别周也太可爱了吧！看了两集就喜欢上这匹马了！中间乐子也迷上了这部番，于是我俩就戴一个耳机一起看了。看了大概两小时吧，困了，就开始睡觉。睡醒忘了在干些啥了，好像是有网了，于是就开始耍电脑。</p><p>快到西安的那一段路，耳压变化明显，大概是因为在下山？</p><p>三点半多在鄠邑站下车，本来打算在车站吃肯德基的，结果到站了发现啥都没有，于是就直接打车去酒店了。</p><p>四点多一点就到酒店了。酒店住南山温泉。在门口申请了健康码之后，就可以办入住手续了。我们总共订了三个标间，我和乐子住一间，我另外两个队友住一间。不知道为什么，我们房间特别大，可能这就是欧皇吧？</p><p>酒店休息（床上打滚）了一会，就去西工大报道了。</p><p>酒店离西工大两公里远，也不知道为什么，我们决定走过去。走到一半大家就都后悔了，但是这时候又不好意思说打车，毕竟都要面子的嘛，然后，仿佛过了很久，我们终于走到了。</p><p>报道是六点结束，我们刚好提前半小时到报道处。提交了相关文件和核酸检测证明之后，很顺利的拿到了物资：一个参赛证、一件短袖T恤、一个书包、几张饭票和一个企业的宣传小册子。在厕所换上衣服，戴好参赛证后，按主办方的要求拍了张照，报道就算完成了。</p><p>然后就是愉快的干饭时间了！西工大食堂的饭菜还不错，我点的五花肉蛋包饭，相比来说，比重邮的蛋包饭要好吃太多了。食堂出来又感觉有点没吃饱，于是又在他们食堂门口买了几串烧烤。。</p><p>然后就直接回酒店了。在酒店玩了会电脑，就去打cf了。这场cf又没打好，卡dp卡了很久，导致一道很简单的01构造题没做出来，到嘴边的烂分没了。期间，乐子他们队在隔壁房间打训练赛，太优秀了吧qaq</p><h2 id="4-17"><a href="#4-17" class="headerlink" title="4.17"></a>4.17</h2><p>为了吃酒店的早饭，特地起了个大早。酒店的早餐一般吧，种类不多，但是味道还算不错。接饮料的机器有点垃圾，停的时候要停好一会，导致咖啡满出来了。另外，沙拉和卷心菜都很好吃。</p><p>吃完回房间。因为昨天已经报道了，所以早上没什么事，于是就打开电脑补昨晚cf的构造题。昨天其实已经写的七七八八了，今天又写了会，wa了几发，就过了。</p><p>然后去洗了个澡，就去补觉了。</p><p>11点多，我两个队友和乐子出发去西工大。由于企业的宣讲并不是很感兴趣，于是中午就不和他们去学校了。点了份外卖，然后就开始改begonia（go写的rpc框架）的bug。改着改着就忘记外卖这回事了，推到github之后发现已经1点了外卖还没到！于是很生气地打电话过去对线。催了好几次后才送到，不过味道还算可以，老板娘态度也还算好，就没那么生气了，然后也忘了给差评。。。</p><p>摸了亿会鱼，就出发去西工大了。到学校是三点左右，刚好赶上开幕式，就顺便过去听了一下。开始是icpc委员会的一个忘了什么职位什么名字的教授致辞，然后只记得：西工大的老师致辞、选手代表宣誓、教练代表致辞。。听的有点无聊，三点四十左右开幕式结束，慢悠悠地前往比赛场地打热身赛。</p><p>比赛场地位于翱翔体育馆。进入场地的那一瞬间，还是让人很震撼的：非常宽广的场地，整洁又密集的桌子上放着队伍牌和电脑，抬头看，是有些晃眼的吊灯。进入集训队一年半的时间，第一次见到如此盛大的场面，有些兴奋，但随即又有些不安。</p><p>然后出了点小问题，转了一圈都没找到我们队伍的位置，然后问志愿者，才发现我们队的位置就在入口附近。</p><p>成功和队友会合后，不一会电脑也解锁了，然后打开电脑开始熟悉环境。</p><p>然后热身赛开始了，然后爆0了。。。</p><p>打完后遇到乐子，发现他们也爆0 了，就很难过。</p><p>体育馆外，有些人去找西工大的同学玩了，我们剩下三个在西工大没有同学的，就在边上的超市买了点东西回酒店了。</p><p>晚饭出于好奇，外卖点了份羊肉泡馍。然后就上当了。大概是我找的店有问题吧，他家的羊肉泡馍很浓的羊骚味。吃了一点就不想再吃了，又点了一份炸排骨。</p><p>8：40，大家都回来之后，我们稍微讨论了一下今天的热身赛。总结了下教训就分开了。</p><p>晚上洗了个澡，就上床睡觉了。</p><p>然后。。一点左右，被窗外的施工的声音吵醒。其实晚上的时候就一直在施工，我以为过一会他们就下班了，睡前也懒得管。然后，施工一直持续到三点多，我也是三点多才睡着的。中间有想过报警，但是我一想到我只是个旅居在外的弱小大学生，想想还是算了。</p><h2 id="4-18"><a href="#4-18" class="headerlink" title="4.18"></a>4.18</h2><p>虽然睡的晚，但还是早早就起床了。七点四十左右下楼吃早饭。有了昨天的教训，今天咖啡终于没撒出来。早上也没啥胃口，就随便吃了点沙拉。</p><p>8点左右打车去西工大。8点20到翱翔体育馆。</p><p>由于没有开始入场，我们就在体育馆外面等了一会。我两个队友早起去学校找打印店打印模板了（其实可以在酒店打印的）。</p><p>会合并且寄存好手机之后，就入场了。然后就开始调试电脑。建文件夹，打开IDE。在clion上配置external tools和keymap（主要是我自己用）。然后就等待发题了。</p><p>比赛开始后就分开读题。签到题是我看的，看完还是有点犹豫的。不过看到前面的队伍很快就过题了之后，我就开始写了。27分钟左右写完，提交，一遍过。看了眼排名，19名，开局还算不错。</p><p>然后开始写另一道全场题。然后就卡了。卡了很久，中间开了a和b，但是也没有想出来。一直到结束前的最后几分钟，才把全场题做出来。。</p><p>然后比赛就结束了。毫无悬念是个铁牌。不久乐子就找到我们了，他们第三题没做出来，挺可惜的。</p><p>然后就是去看颁奖典礼和闭幕式。</p><p>没想到的是闭幕式之前还有一波企业宣讲。然后我就听睡着了，一直到华为讲完才睡醒。闭幕式也没啥好说的，不过滚榜还是很有意思的。没有拿到顽强拼搏奖，还是有点可惜的。</p><p>闭幕式结束之后，去翱翔体育馆门口补了张照片，然后就坐车去大秦酒店参加晚宴。有两个同学觉得麻烦，就没去。</p><p>一开始我还以为大秦很近，结果坐了两个小时的车才到。到了之后都饿坏了，遂开始狼吞虎咽地扒饭。晚宴吃的是自助餐，菜还算好吃吧，可惜有点冷了。特别喜欢肥牛和五花肉。不过晚宴上还有个看起来像是酸辣粉一样的东西，拿了之后发现是芥末qaq。</p><p>然后就开始表演了。现场音响实在是有些一般，歌感觉不是很好听。然后就是一些演讲、游戏，和抽奖了。由于前几轮都没抽到我，于是就换了个头像希望转运。然后，就抽到了个平板。在大佬们略微有些羡慕的眼神中上台领奖，大概是我这次参赛唯二的高光了吧。</p><p>九点多发车回酒店。晚上11点到，洗了个澡，上GitHub看了一圈开源oj，就睡了。</p><p>第二天返程，很顺利，就不说了。</p><p>西安之旅就这样结束了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>打铁了还是挺不甘心的吧，特别是现场赛打铁，让人更能感受和大佬之间的差距。</p><p>去年拿了银牌之后，其实还是有一点骄傲的。但同时也明白那个银牌还是有一点运气成分的（毕竟银牌题其实并没有做出来）。也一直想证明自己配得上这块银牌吧，包括2月3月也刷了不少题，不过就结果来看，做的题还是远远不够的。</p><p>总之，以后要好好训练了（不能再偷懒不打cf了）。</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E5%85%B6%E4%BB%96/">其他</category>
      
      
      <comments>http://example.com/2021/04/23/2020ECFinal-Middle-%E6%B8%B8%E8%AE%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Cut and Stick</title>
      <link>http://example.com/2021/04/23/Cut-and-Stick/</link>
      <guid>http://example.com/2021/04/23/Cut-and-Stick/</guid>
      <pubDate>Fri, 23 Apr 2021 01:00:50 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;timudayi&lt;/p&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://codeforces.com/problemset/problem/1514/D&quot;&gt;https://codeforces.com/problemset/problem/1514/D&lt;/a&gt;&lt;/p&gt;
&lt;h</description>
        
      
      
      
      <content:encoded><![CDATA[<p>timudayi</p><p>链接：<a href="https://codeforces.com/problemset/problem/1514/D">https://codeforces.com/problemset/problem/1514/D</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长为n的序列a，有q次询问，每次询问给定一个区间$[l, r]$，问最少要将这个区间划分多少次（不一定连续），使得每个划分（假设长度为len）里众数的个数f满足：$f\leq \lceil \frac {len} 2 \rceil$。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>如果对于$[l,r]$，众数个数已经小于等于$\lceil \frac{len} 2 \rceil$，那么就不用再划分子了。</p><p>否则，就存在这样一种构造法：</p><p>假设众数个数为f，那么就剩下的数有len-f个，这些len-f个非众数数可以和len-f+1个众数一起划分到一个子区间中。剩下的众数就单独划分到一个集合中，总共需要$1+f-(len-f+1)=2*f-len$个划分。</p><p>那么现在的问题就是怎么快速求众数了。</p><p>一般来说，要使用莫队算法。但是在这道题中，出现次数未超过$\lceil \frac{len} 2 \rceil$的众数并没有意义，所以我们也可以用主席树求。具体看代码，时间复杂度$O(n\log  n)$。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> *sum, *ls, *rs;</span><br><span class="line">    <span class="keyword">int</span> n, cnt;</span><br><span class="line"></span><br><span class="line">    Tree(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[n &lt;&lt; <span class="number">5</span>];</span><br><span class="line">        ls = <span class="keyword">new</span> <span class="keyword">int</span>[n &lt;&lt; <span class="number">5</span>];</span><br><span class="line">        rs = <span class="keyword">new</span> <span class="keyword">int</span>[n &lt;&lt; <span class="number">5</span>];</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = ++cnt;</span><br><span class="line">        sum[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            ls[rt] = build(l, mid);</span><br><span class="line">            rs[rt] = build(mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rt = ++cnt;</span><br><span class="line">        ls[rt] = ls[pre], rs[rt] = rs[pre], sum[rt] = sum[pre] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= mid) ls[rt] = update(ls[pre], l, mid, x);</span><br><span class="line">            <span class="keyword">else</span> rs[rt] = update(rs[pre], mid + <span class="number">1</span>, r, x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找有没有大于一半的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> sum[v] - sum[u];</span><br><span class="line">        <span class="keyword">if</span> (sum[v] - sum[u] &lt;= lim) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = sum[ls[v]] - sum[ls[u]], y = sum[rs[v]] - sum[rs[u]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; lim &amp;&amp; (res = query(ls[u], ls[v], l, mid, lim)) &gt; lim) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span> (y &gt; lim &amp;&amp; (res = query(rs[u], rs[v], mid + <span class="number">1</span>, r, lim)) &gt; lim) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], rt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    m = unique(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - (b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">Tree <span class="title">t</span><span class="params">(N)</span></span>;</span><br><span class="line">    rt[<span class="number">0</span>] = t.build(<span class="number">1</span>, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = lower_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + m, a[i]) - b;</span><br><span class="line">        rt[i] = t.update(rt[i - <span class="number">1</span>], <span class="number">1</span>, m, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> lim = <span class="built_in">ceil</span>((r - l + <span class="number">1.0</span>) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> f = t.query(rt[l - <span class="number">1</span>], rt[r], <span class="number">1</span>, m, lim);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, max(<span class="number">1</span>, <span class="number">2</span> * f - (r - l + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2021/04/23/Cut-and-Stick/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Codeforces Round 707(div 2)</title>
      <link>http://example.com/2021/03/14/Codeforces%20Round%20707(div%202)/</link>
      <guid>http://example.com/2021/03/14/Codeforces%20Round%20707(div%202)/</guid>
      <pubDate>Sat, 13 Mar 2021 18:41:09 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;A-Alexey-and-Train&quot;&gt;&lt;a href=&quot;#A-Alexey-and-Train&quot; class=&quot;headerlink&quot; title=&quot;A. Alexey and Train&quot;&gt;&lt;/a&gt;A. Alexey and Train&lt;/h2&gt;&lt;p&gt;链接：&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="A-Alexey-and-Train"><a href="#A-Alexey-and-Train" class="headerlink" title="A. Alexey and Train"></a>A. Alexey and Train</h2><p>链接：<a href="https://codeforces.com/problemset/problem/1501/A">https://codeforces.com/problemset/problem/1501/A</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有一列火车，要从站台1开往站台n，现在给你预期到达时间$a_i$和预期发车时间$b_i$，以及列车在从i-1站驶向i站时的延误时间$tm_i$，求火车到达站台n的时间。</p><p>当延误时，列车在站台i停靠的时长T应满足：</p><ul><li>$T\geq \lceil\frac {b_i - a_i} 2\rceil$</li><li>使实际发车时间$\geq$预期发车时间</li></ul><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>简单模拟，计算出到达每一站的时间和从每一站出发的时间即可。</p><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], t[N];</span><br><span class="line"><span class="keyword">int</span> aa[N], bb[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(aa, <span class="number">0</span>, <span class="keyword">sizeof</span> aa);</span><br><span class="line">        <span class="built_in">memset</span>(bb, <span class="number">0</span>, <span class="keyword">sizeof</span> bb);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, a + i, b + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, t + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            aa[i] = a[i] - b[i - <span class="number">1</span>] + t[i] + bb[i - <span class="number">1</span>];</span><br><span class="line">            bb[i] = max(aa[i] + (<span class="keyword">int</span>)<span class="built_in">ceil</span>((b[i] - a[i] + <span class="number">0.0</span>) / <span class="number">2</span>), b[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; aa[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Napoleon-Cake"><a href="#B-Napoleon-Cake" class="headerlink" title="B. Napoleon Cake"></a>B. Napoleon Cake</h2><p>链接：<a href="https://codeforces.com/problemset/problem/1501/B">https://codeforces.com/problemset/problem/1501/B</a></p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个长度为n数组，初始值都是0，有n次操作，操作i给定$a_i$，让你给区间$[i-a_i+1,i]$都加上1，最后问你哪些位大于0，哪些位等于0。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>因为可以很显然的转化为区间维护问题，没多想就直接上树状数组了，就ac了（幸好没卡$n\log n$）。</p><p>但是，fzh大佬指出，差分前缀和可以在$o(n)$的复杂度内解决问题，是我菜了</p><h3 id="AC代码-树状数组"><a href="#AC代码-树状数组" class="headerlink" title="AC代码(树状数组)"></a>AC代码(树状数组)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, a[N], t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n &lt;&lt; <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowb</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, ll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowb(x)) t[x] += k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x &gt; <span class="number">0</span>; x -= lowb(x)) res += t[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modlify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    l = max(l, <span class="number">1</span>);</span><br><span class="line">    update(l, <span class="number">1</span>);</span><br><span class="line">    update(r + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) modlify(i - a[i] + <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (query(i) &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Going-Home"><a href="#C-Going-Home" class="headerlink" title="C. Going Home"></a>C. Going Home</h2><p>链接：<a href="https://codeforces.com/problemset/problem/1501/C">https://codeforces.com/problemset/problem/1501/C</a></p><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n个数（$n\leq 2e5$）$a_1,a_2……a_n$（$a_i\leq2.5e6$），找出四个<strong>不同</strong>的整数x，y，z，w，使得$a_x+a_y=a_z+a_w$。</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>看到题目你是不是想到了meeting in the middle？如果是，那么你答对了$\sqrt{max(n)}$。</p><p>如果只看n的范围，不难猜测，我们需要在$O(n\log n)$的时间内解决这个问题，显然这几乎是不可能（是我能解决）的。但是$a_i$的值域给了一个非常奇怪的数2.5e6，这让我们有了操作空间。</p><p>首先，如果同一个数出现超过三次，那么可以很显然的得到答案，所以，我们考虑所有数出现的次数都小于等于3的情况。</p><p>此时，就算序列a中的每一个数都出现了3次，我们依然<strong>有超过5e4个不同的数</strong>。</p><p>我们先把序列a从小到大排列，再把重复的数去掉，得到新的序列$A_1,A_2……A_m$。再对序列A做差分，得到序列$b1,b2……bm-1$，其中$b_i=a_{i+1}-a_i$。</p><p>此时，我们可以得到结论：$若i-j\geq 2 \ 且\  b_i=b_j $，那么i+1，j，i，j+1就是所求解。</p><p>那么我们假设出题者非常恶毒，他想使所有的$b_i$都尽量不相等！那么在最严苛的条件下，就有:</p><script type="math/tex; mode=display">b_1=1, \\ b_2=1, \\b_3=2, \\b_4=2, \\…… \\b_n=\lceil \frac n 2 \rceil</script><p>这时就恰好无解了（很烦）。</p><p>我们在这个条件下我们对序列b求和:</p><script type="math/tex; mode=display">\sum{b_i}\approx 2*\frac {(1+\frac n 2)*\frac n 2} 2\\=(1+\frac n 2)*\frac n 2 \\ \approx \frac {n^2} 4</script><p>$又\because \ \ \ \  \ \sum b_i=max\{a_i\}-min\{a_i\}=2.5e6=A_m-A_1$（因为是差分）</p><p>$\therefore\ \  \ A_m-A_1=\frac {n^2} 4$</p><p>如果<strong>此时</strong>，我们将某个$b_i（i&gt;2）$减少1，那么就变成了：</p><p>$\therefore\ \  \ A_m-A_1=\frac {n^2} 4-1&lt;\frac {n^2} 4$</p><p>注意，序列b是对序列A差分得到，因此b的和永远是$A_m-A_1(等式左边)$，但是，$\frac {n^2} 4$是由等差数列求和算的。当$b_i$发生变化时，序列b就不再是等差数列，因此求和也不可以再直接由等差数列求和得到（但是可以通过补全为等差数列求和得到）。</p><p>不难发现某个$b_i（i&gt;2）$减少1后，就必然会出现元素相同的情况，此时满足$i-j\geq 2 \ 且\  b_i=b_j $，因此一定有解。</p><p>同理，如果继续减小$b_i（i&gt;2）$，也必然会有解的，</p><p>因此，当$\therefore\ \  \ A_m-A_1&lt;\frac {n^2} 4$时，我们一定能找到解。</p><p>由于，$A_m-A_1<2.5e6$，所以只要$n>1000\sqrt 10\approx3162.27$，就必然有解，且必然有一组解是在序列A中两对不相交的相邻的两个数。</p><p>如果不满足这个条件，由于数据很小，暴力就好了 ，<del>芜湖！</del></p><p>另外如果你足够有耐心，也可以精确算出必然有解的条件（注意上述过程只是估算，实际上n的取值最好大于3200）。</p><h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="comment">// val = x - y (n&gt;3e3)</span></span><br><span class="line">    <span class="comment">// val = x + y (else)</span></span><br><span class="line">    <span class="keyword">int</span> val, x, y;</span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> v, <span class="keyword">int</span> xx, <span class="keyword">int</span> yy) : val(v), x(xx), y(yy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; rhs.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N], n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">3e3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        sort(a, a + n);</span><br><span class="line">        <span class="function">node <span class="title">t</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; s.count(node(a[i] - a[i - <span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = s.find(node(a[i] - a[i - <span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                ans[<span class="number">0</span>] = x-&gt;x;</span><br><span class="line">                ans[<span class="number">1</span>] = i - <span class="number">1</span>;</span><br><span class="line">                ans[<span class="number">2</span>] = x-&gt;y;</span><br><span class="line">                ans[<span class="number">3</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) s.insert(t); <span class="comment">// 注意这里的细节，不能直接插入</span></span><br><span class="line">            t = node(a[i] - a[i - <span class="number">1</span>], i, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = ans[k];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; k; kk++)</span><br><span class="line">                        <span class="keyword">if</span> (ans[kk] == j) &#123;</span><br><span class="line">                            ok = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ok) ans[k] = j;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> an : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, an + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                    <span class="keyword">if</span> (i != j &amp;&amp; !s.count(node(a[i] + a[j], <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">                        s.insert(node(a[i] + a[j], i, j));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.count(node(a[i] + a[j], <span class="number">0</span>, <span class="number">0</span>))) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> p = s.find(node(a[i] + a[j], <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">                        <span class="keyword">if</span> (p-&gt;x != i &amp;&amp; p-&gt;y != j &amp;&amp; p-&gt;x != j &amp;&amp; p-&gt;y != i) &#123;</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, i + <span class="number">1</span>, j + <span class="number">1</span>, p-&gt;x + <span class="number">1</span>, p-&gt;y + <span class="number">1</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2021/03/14/Codeforces%20Round%20707(div%202)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>cf edu(round100)-Find The Array</title>
      <link>http://example.com/2020/12/18/cf-edu-round100-Find-The-Array/</link>
      <guid>http://example.com/2020/12/18/cf-edu-round100-Find-The-Array/</guid>
      <pubDate>Thu, 17 Dec 2020 16:56:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;链接：&lt;a href=&quot;https://codeforces.ml/contest/1463/problem/B&quot;&gt;https://codeforces.ml/contest/1463/problem/B&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目</description>
        
      
      
      
      <content:encoded><![CDATA[<p>链接：<a href="https://codeforces.ml/contest/1463/problem/B">https://codeforces.ml/contest/1463/problem/B</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个序列a[1..n]，其中$1\leq a_i \leq 10^9$，S为a所有元素的和。要求构造一个”美丽序列“B[1..n]满足：</p><ul><li>$1≤b_i≤10^9 $</li><li>要么$b_i$ 整除$b_{i+1}$ ，要么$b_{i + 1}$ 整除$b_i$ 。</li><li>$2\sum_{i=1}^{n}{|a_i-b_i|}\leq S$</li></ul><p>保证一定有解，输出任意一种。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>很有意思但是不难的构造题。</p><p>因为是第三个条件的左边有个系数2，不难想到利用2进制进行构造。具体做法为，对于任意$a_i$，其对应的$b_i$就是$2^{\lfloor \log_{2}{a_i}\rfloor}$，也就是$a_i$的二进制最高位。</p><p>这时我们不难发现，$|a_i-b_i|\leq \frac{a_i}2$，所以一定是满足条件3的。同时，因为B[1..n]都是2的幂，因此任意B的任意两个元素必然有一个可以整除对方。于是这道题就这么做完了<del>（又水了一骗博客）</del>。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getB</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &gt; x) <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, getB(a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2020/12/18/cf-edu-round100-Find-The-Array/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020ICPC（上海）-Mine Sweeper II</title>
      <link>http://example.com/2020/12/18/2020ICPC%EF%BC%88%E4%B8%8A%E6%B5%B7%EF%BC%89-Mine-Sweeper-II/</link>
      <guid>http://example.com/2020/12/18/2020ICPC%EF%BC%88%E4%B8%8A%E6%B5%B7%EF%BC%89-Mine-Sweeper-II/</guid>
      <pubDate>Thu, 17 Dec 2020 16:55:28 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/9925/B&quot;&gt;https://ac.nowcoder.com/acm/contest/9925/B&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/contest/9925/B">https://ac.nowcoder.com/acm/contest/9925/B</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你2个n×m扫雷图A、B，图中没有雷的格子会有一个数字x，表示这个格子周围9×9的格子中有多少个雷。现在你可以最多修改B图$\frac {nm}2$次来使得两个图中的数字之和相等，输出修改后的B图。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑数字和就等于相邻（雷格子，非雷格子）二元组的个数，于是把整个地图全反过来这个二元组个数不变，然后 $B$ 与 $A$之间以及 $B$ 与 $inv(A)$ ，即把 $A$ 所有格子全部取反的扫雷地图之间总有一个偏差不超过一半的，所以就选其中偏差不超过一半的然后变过去就行。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ga[N][N], gb[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, cntOri, cntInv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, gb[i][j] ? <span class="string">&#x27;X&#x27;</span> : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);</span><br><span class="line">            ga[i][j] = ch == <span class="string">&#x27;X&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch);</span><br><span class="line">            gb[i][j] = ch == <span class="string">&#x27;X&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            cntOri += ga[i][j] ^ gb[i][j] ^ <span class="number">1</span> ;</span><br><span class="line">            cntInv += ga[i][j] ^ gb[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> f = cntOri &gt; cntInv ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            gb[i][j] = ga[i][j] ^ f;</span><br><span class="line">        &#125;</span><br><span class="line">    print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2020/12/18/2020ICPC%EF%BC%88%E4%B8%8A%E6%B5%B7%EF%BC%89-Mine-Sweeper-II/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HDU 5475.An easy problem</title>
      <link>http://example.com/2020/12/15/HDU-5475-An-easy-problem/</link>
      <guid>http://example.com/2020/12/15/HDU-5475-An-easy-problem/</guid>
      <pubDate>Mon, 14 Dec 2020 16:21:41 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;一开始给你一个数n=1和一个模数M（不一定为质数），之后会有q（$q&amp;lt;10^5$）次操作，每次操作操作给两个数f，x（</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一开始给你一个数n=1和一个模数M（不一定为质数），之后会有q（$q&lt;10^5$）次操作，每次操作操作给两个数f，x（$x&lt;10^9$）</p><ul><li>f=1时，表示给n乘上x</li><li>f=2时，表示给n除以第x次操作乘的那个数</li></ul><p>每次操作后输出n对M取模的值。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为M不为质数，所以显然不能用逆元。x也很大，高精很有可能被卡时间复杂度。此时不难想到万能数据结构——分块。</p><p>具体做法是，将每次乘的数放到一个块里，然后对于每个块维护乘数模M的结果<strong>ans[i]</strong>。当f=1时，将x插入到相应的块中，同时将<strong>ans[i]</strong>乘上x再取模。当f=2时，将块中的x直接修改为1，并暴力重构块。</p><p>每次操作后n的值就是<strong>ans[]</strong>的积。</p><p>当然线段树也是可以的。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">opt</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f, x;</span><br><span class="line">&#125;o[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> block[<span class="number">1000</span> + <span class="number">5</span>][<span class="number">2000</span> + <span class="number">5</span>], p[<span class="number">1000</span> + <span class="number">5</span>], ans[<span class="number">1000</span> + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> arr[N];</span><br><span class="line"><span class="keyword">int</span> n, q, m, lenBlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lower_bound(arr, arr + q, x) - arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    ans[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p[x]; i++) ans[x] = ans[x] * <span class="number">1l</span>l * block[x][i] % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res = res * <span class="number">1l</span>l * ans[i] % m;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = id(x), i = pos / lenBlock;</span><br><span class="line">    block[i][p[i]++] = x;</span><br><span class="line">    ans[i] = ans[i] * <span class="number">1l</span>l * x % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = id(x), i = pos / lenBlock;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p[i]; j++) <span class="keyword">if</span> (block[i][j] == x)&#123;</span><br><span class="line">        block[i][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> kase = <span class="number">1</span>; kase &lt;= T; kase++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;o[i].f, &amp;o[i].x);</span><br><span class="line">            arr[i] = o[i].x;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr, arr + q);</span><br><span class="line">        lenBlock = <span class="built_in">sqrt</span>(q + <span class="number">0.5</span>);</span><br><span class="line">        n = <span class="built_in">ceil</span>((q + <span class="number">0.0</span>) / lenBlock);</span><br><span class="line">        build();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, kase);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o[i].f == <span class="number">1</span>) add(o[i].x), res = res * <span class="number">1l</span>l * o[i].x % m;</span><br><span class="line">            <span class="keyword">else</span> del(o[o[i].x - <span class="number">1</span>].x), res = getAns();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2020/12/15/HDU-5475-An-easy-problem/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>HDU5478-Can you find it</title>
      <link>http://example.com/2020/12/15/HDU5478-Can-you-find-it/</link>
      <guid>http://example.com/2020/12/15/HDU5478-Can-you-find-it/</guid>
      <pubDate>Mon, 14 Dec 2020 16:16:03 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;有一个对于一个有序数对$(a,b)$和$k1,k2,b1$，要求满足等式  &lt;script type=&quot;math/tex&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有一个对于一个有序数对$(a,b)$和$k1,k2,b1$，要求满足等式  <script type="math/tex">a^{k1⋅n+b1}+ b^{k2⋅n−k2+1} \equiv 0 (mod C)(\forall n = 1, 2, 3, ...)</script></p><p> 问这样的a,b 有多少对？以字典序输出。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当n=1时，有</p><p>$a^{k1+b1}+b\equiv0(modC)$        ————式1</p><p>当n=2时，有</p><p>$a^{k1+b1}a^{k1}+bb^{k2}\equiv0(modC)$        ————式2</p><p>又因为 $a^{k1+b1}a^{k1}+ba^{k1}\equiv0(modC)$</p><p>所以有$a^{k1}\equiv b^{k2}（modC)$</p><p>显然，当n等于1，2时都满足等式的话，后面也是一定会满足的（归纳法）。</p><p>所以我们只要判断前两种情况就好了。具体来说，枚举a的所有可能值（1~C-1），然后根据式1算出b，再去判断a，b是否满足式2。由于是从小到大枚举a，因此一定是满足字典序的</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll C, k1, k2, b1;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll base, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll res = qpow(base, p &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    res = res * <span class="number">1l</span>l * res % C;</span><br><span class="line">    <span class="keyword">if</span> (p &amp; <span class="number">1</span>) res = res * <span class="number">1l</span>l * base % C;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; C &gt;&gt; k1 &gt;&gt; b1 &gt;&gt; k2) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>, ++kase);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ll a = <span class="number">1</span>; a &lt; C; a++) &#123;</span><br><span class="line">            ll b = C - qpow(a, k1 + b1);</span><br><span class="line">            <span class="keyword">if</span> ((qpow(a, (k1 &lt;&lt; <span class="number">1</span>) + b1) + qpow(b, k2 + <span class="number">1</span>)) % C == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, a, b);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2020/12/15/HDU5478-Can-you-find-it/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>进程内缓存bigcache</title>
      <link>http://example.com/2020/12/06/%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98bigcache/</link>
      <guid>http://example.com/2020/12/06/%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98bigcache/</guid>
      <pubDate>Sun, 06 Dec 2020 07:23:47 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;github地址：&lt;a href=&quot;https://github.com/allegro/bigcache&quot;&gt;https://github.com/allegro/bigcache&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;heade</description>
        
      
      
      
      <content:encoded><![CDATA[<p>github地址：<a href="https://github.com/allegro/bigcache">https://github.com/allegro/bigcache</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><del>先扒一波官方文档凑字数</del></p><blockquote><p>Fast, concurrent, evicting in-memory cache written to keep big number of entries without impact on performance. BigCache keeps entries on heap but omits GC for them. To achieve that, operations on byte slices take place, therefore entries (de)serialization in front of the cache will be needed in most use cases.</p><p>机器翻译：快速，并发，驱逐内存中的高速缓存，以保持大量的条目不影响性能.BigCache将条目保存在堆中，但忽略了它们的GC。为此，对字节片进行操作，因此在大多数用例中都需要缓存前面的条目(反序列化)。</p></blockquote><p>虽然redis具有非常不错的性能（官方数据读的速度是110000次/秒,写的速度是81000次/秒），但是这并不等于我们一个进程在一秒可以对redis做好几万次操作。比如，现在基本都是用TCP协议建立与本地redis的连接，那么每次对redis进行操作都要把数据打包发到运输层，运输层再发到网络层，然后才返回发到本地的redis进程上。虽然使用pipeline可以减少一部分I/O时间消耗，但总归还是有性能瓶颈，很难达到每秒几万的操作效率。</p><p>因此，在没有使用分布式服务器的情况下，进程内缓存就显得很好用了。</p><p>此外，bigcache还拥有以下非常好用的特性：</p><ul><li>即使拥有百万记录也非常快（主要用哈希实现）</li><li>提供并发访问</li><li>在预定的时间后移除记录</li></ul><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><del>又来扒拉一波官方文档</del></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/allegro/bigcache&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个缓存</span></span><br><span class="line">    cache, _ := bigcache.NewBigCache(bigcache.DefaultConfig(<span class="number">10</span> * time.Minute))</span><br><span class="line"></span><br><span class="line">    cache.Set(<span class="string">&quot;my-unique-key&quot;</span>, []<span class="keyword">byte</span>(<span class="string">&quot;value&quot;</span>))</span><br><span class="line"></span><br><span class="line">    entry, _ := cache.Get(<span class="string">&quot;my-unique-key&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(entry))   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该库主要有以下几个特点</p><ul><li>主要操作只有Set、Get、Delete、Len</li><li>只能存取[]byte类型</li><li>config对象的设置对速度的影响较大</li><li>需要用自定义的config时需要实现Hasher接口</li></ul><h2 id="config对象简介"><a href="#config对象简介" class="headerlink" title="config对象简介"></a>config对象简介</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Config for BigCache</span></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Number of cache shards, value must be a power of two</span></span><br><span class="line">    <span class="comment">// 分片类型的数量，用于并发优化</span></span><br><span class="line">Shards <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Time after which entry can be evicted</span></span><br><span class="line">    <span class="comment">// 第一次删除的时间</span></span><br><span class="line">LifeWindow time.Duration</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Interval between removing expired entries (clean up).</span></span><br><span class="line"><span class="comment">// If set to &lt;= 0 then no action is performed. Setting to &lt; 1 second is counterproductive — bigcache has a one second resolution.</span></span><br><span class="line">    <span class="comment">// 删除的时间间隔</span></span><br><span class="line">CleanWindow time.Duration</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Max number of entries in life window. Used only to calculate initial size for cache shards.</span></span><br><span class="line"><span class="comment">// When proper value is set then additional memory allocation does not occur.</span></span><br><span class="line"><span class="comment">// 大概就是删除队列的初始大小，在一开始分配，超过了就动态扩容</span></span><br><span class="line">    MaxEntriesInWindow <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Max size of entry in bytes. Used only to calculate initial size for cache shards.</span></span><br><span class="line">    <span class="comment">// 单个value的最大大小，用于计算初始cache shards大小</span></span><br><span class="line">MaxEntrySize <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Verbose mode prints information about new memory allocation</span></span><br><span class="line">    <span class="comment">// 机器翻译：详细模式打印有关新内存分配的信息</span></span><br><span class="line">Verbose <span class="keyword">bool</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Hasher used to map between string keys and unsigned 64bit integers, by default fnv64 hashing is used.</span></span><br><span class="line">    <span class="comment">// 你要使用的哈希函数</span></span><br><span class="line">Hasher Hasher</span><br><span class="line">    </span><br><span class="line"><span class="comment">// HardMaxCacheSize is a limit for cache size in MB. Cache will not allocate more memory than this limit.</span></span><br><span class="line"><span class="comment">// It can protect application from consuming all available memory on machine, therefore from running OOM Killer.</span></span><br><span class="line"><span class="comment">// Default value is 0 which means unlimited size. When the limit is higher than 0 and reached then</span></span><br><span class="line"><span class="comment">// the oldest entries are overridden for the new ones.</span></span><br><span class="line">    <span class="comment">// 最大占用内存，不够用时会覆盖就内存，和redis有点像</span></span><br><span class="line">HardMaxCacheSize <span class="keyword">int</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// OnRemove is a callback fired when the oldest entry is removed because of its expiration time or no space left</span></span><br><span class="line"><span class="comment">// for the new entry, or because delete was called.</span></span><br><span class="line"><span class="comment">// Default value is nil which means no callback and it prevents from unwrapping the oldest entry.</span></span><br><span class="line">    <span class="comment">// 由于各种原因删除数据时会触发的回调函数</span></span><br><span class="line">OnRemove <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, entry []<span class="keyword">byte</span>)</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// OnRemoveWithReason is a callback fired when the oldest entry is removed because of its expiration time or no space left</span></span><br><span class="line"><span class="comment">// for the new entry, or because delete was called. A constant representing the reason will be passed through.</span></span><br><span class="line"><span class="comment">// Default value is nil which means no callback and it prevents from unwrapping the oldest entry.</span></span><br><span class="line"><span class="comment">// Ignored if OnRemove is specified.</span></span><br><span class="line">    <span class="comment">// 用于传递释放数据的原因，有Expired，NoSpace，Deleted三种</span></span><br><span class="line">OnRemoveWithReason <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, entry []<span class="keyword">byte</span>, reason RemoveReason)</span></span></span><br><span class="line"></span><br><span class="line">onRemoveFilter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger is a logging interface and used in combination with `Verbose`</span></span><br><span class="line"><span class="comment">// Defaults to `DefaultLogger()`</span></span><br><span class="line">    <span class="comment">// 日志</span></span><br><span class="line">Logger Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优化的一些原理"><a href="#优化的一些原理" class="headerlink" title="优化的一些原理"></a>优化的一些原理</h2><h3 id="1、并发优化"><a href="#1、并发优化" class="headerlink" title="1、并发优化"></a>1、并发优化</h3><p>由于bigcache支持并发，因此势必会用锁（事实用的是读写锁）。在高并发场景下，如果只用一把读写锁，势必会显著影响读写速度。解决方案是用分块的思想（想必大家在数据结构上都听老师口糊过），把整个内存分成N个部分，每个部分单独分配一把锁保证并发安全。在哈希函数足够优秀的情况下，就可以实现同时允许好几个协程进行读写。</p><p>所以这部分的优化主要是N的选择以及哈希函数的选择。</p><h4 id="（1）N的选择"><a href="#（1）N的选择" class="headerlink" title="（1）N的选择"></a>（1）N的选择</h4><p> 首先N肯定不是越大越好，因为太大会带来很多不必要的开销（增加内存使用和寻找所在分块的时间），且性能提升也未必会很明显，所以要在性能和花销上寻找一个平衡。框架作者推荐的值是1024。</p><p>另外，N的值最好是2的幂，因为这样底层可以直接用位运算取模，进一步减少时间开销。</p><h4 id="（2）Hash算法的选择"><a href="#（2）Hash算法的选择" class="headerlink" title="（2）Hash算法的选择"></a>（2）Hash算法的选择</h4><p><del>太玄学了还是算了</del></p><p>看了半天还是用他内置的FNV64a算法吧。</p><h3 id="2、GC优化"><a href="#2、GC优化" class="headerlink" title="2、GC优化"></a>2、GC优化</h3><p>Go1.5对GC进行了优化，如果map中的键值对都是基本类型，则GC会忽略他们。</p><p>因此框架作者利用这一特性，在每个分块中用map[uint64]uint32和一个预先分配的大字节数组（数组还是切片暂时没有证实）存储数据，把缓存对象序列化的后放到预先分配好的大字节数组中，把它的哈希值作为map[uint64]uint32的key，然后把它在数组中的offset作为map[uint64]uint32的value。</p>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E5%90%8E%E7%AB%AF/">后端</category>
      
      
      <comments>http://example.com/2020/12/06/%E8%BF%9B%E7%A8%8B%E5%86%85%E7%BC%93%E5%AD%98bigcache/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Fibnaci</title>
      <link>http://example.com/2020/10/22/fibnaci/</link>
      <guid>http://example.com/2020/10/22/fibnaci/</guid>
      <pubDate>Thu, 22 Oct 2020 03:21:25 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;谈谈如何设计算法快速求出斐波那契第$n(n &amp;lt; 10^{18})$项？由于结果很大，因此输出对99999989取模的结果。&lt;/p&gt;
&lt;p&gt;提示：1、99999989是质数；2、浮点数在经历多次运算后可能会出现精度不够的情况而导致答案错误；3、&lt;math.h&gt;中的pow</description>
        
      
      
      
      <content:encoded><![CDATA[<p>谈谈如何设计算法快速求出斐波那契第$n(n &lt; 10^{18})$项？由于结果很大，因此输出对99999989取模的结果。</p><p>提示：1、99999989是质数；2、浮点数在经历多次运算后可能会出现精度不够的情况而导致答案错误；3、<math.h>中的pow函数很慢，因此您可能需要重新设计pow函数。</p><p>参考公式：斐波那契的通项公式为：</p><p>$\frac 1 {\sqrt{5}}[(\frac {1+\sqrt{5}} 2)^n-(\frac {1-\sqrt{5}} 2)^n]$</p><p>参考答案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> MOD = <span class="number">99999989</span>; <span class="comment">//模数，这里保证是一个奇质数</span></span><br><span class="line"><span class="keyword">int</span> inv5 = <span class="number">50122571</span>; <span class="comment">// 根号5的对MOD取模的结果，暴搜得到</span></span><br><span class="line"><span class="comment">//这是负根号5：49877418</span></span><br><span class="line"><span class="comment">//也可以用二次剩余定理求，但这里没必要</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 朴素快速幂，时间上已经足够所以没有用欧拉函数优化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> base, ll p, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = qpow(base, p &gt;&gt; <span class="number">1</span>, mod);</span><br><span class="line">    res = res * <span class="number">1l</span>l * res % mod;</span><br><span class="line">    <span class="keyword">if</span> (p &amp; <span class="number">1</span>)  res = res * <span class="number">1l</span>l * base % mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆元，费马小定理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qpow(x, mod - <span class="number">2</span>, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模意义下取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用通项公式求斐波那契第n项，时间 O(log MOD)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">abs</span>(<span class="number">1</span> + inv5, mod) * <span class="number">1l</span>l * inv(<span class="number">2</span>, mod) % mod;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="built_in">abs</span>(<span class="number">1</span> - inv5, mod) * <span class="number">1l</span>l * inv(<span class="number">2</span>, mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> inv(inv5, mod) * <span class="number">1l</span>l * <span class="built_in">abs</span>(qpow(a, n, mod) - qpow(b, n, mod), mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, mod = MOD;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fib(n, mod));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2020/10/22/fibnaci/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Zeldain Garden</title>
      <link>http://example.com/2020/10/15/Zeldain-Garden/</link>
      <guid>http://example.com/2020/10/15/Zeldain-Garden/</guid>
      <pubDate>Wed, 14 Oct 2020 16:15:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/7817/E&quot;&gt;https://ac.nowcoder.com/acm/contest/7817/E&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/contest/7817/E">https://ac.nowcoder.com/acm/contest/7817/E</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个区间$[n,m]$,统计这个区间内所有数的因数个数之和（包括1和自身），$1\leqslant n \leqslant m\leqslant 10^{12}$</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>考虑一个数m的情况：由于所有因数总是成对出现，我们只需要枚举$[1,\sqrt{m}]$即可找出m的所有因数。</p><p>引申到区间，首先我们发现，<strong>$[n,m]$中所有数的因数对中，较小的那一个一定会小于$\sqrt{m}$,</strong>写成命题的话就是：</p><blockquote><p>如果$a*b=x且x\in[n,m]，那么min\{a,b\}\leqslant\sqrt{m} $</p></blockquote><p>根据这个性质，我们从1到$\sqrt{m}$枚举其中一个因子 $x$,找到这样两个整数$l$，$r$使得：</p><script type="math/tex; mode=display">x\leqslant l\leqslant r ,且 n\leqslant l*x \leqslant r*x\leqslant m</script><p>为什么$l,r$要比x大呢？这是为了防止重复计算。如果我们有这样一个数$y$使得</p><script type="math/tex; mode=display">n \leqslant y * y \leqslant m且y * (y-1) \geq n</script><p>那么在缺少这个限制时$y$和$y-1$这一对因数就会在$x=y,x=y-1$时分别被计算一次，答案就比正确答案大2。($ y-2,y-3…$同理)</p><p>这样，$[n,m]$中所有以x为因子的数的个数就是$r-l+1$，由于因数成对出现，我们就找到了$2*(r-l+1)$个因数。</p><p>值得注意的是平方数会多算一个因数，最后要把多余的数减掉。</p><h2 id="AC代码："><a href="#AC代码：" class="headerlink" title="AC代码："></a>AC代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line">ll n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(ll k)</span> </span>&#123;</span><br><span class="line">    ll l = n / k + (n % k ? <span class="number">1</span> : <span class="number">0</span>), r = m / k;</span><br><span class="line">    l = max(l, k); <span class="comment">//防止重复统计</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i * i &lt;= m; ++i) &#123;</span><br><span class="line">        ans +=  calc(i);</span><br><span class="line">        <span class="keyword">if</span> (i * i &gt;= n) ans--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://example.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://example.com/2020/10/15/Zeldain-Garden/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
